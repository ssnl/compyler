/* This is a Horn file that will allow you to test your solution.  */

/* Use 'gmake' with the Makefile in this directory to convert this
 * file to C++ (using Horn) and then compile it to
 * produce class executable file 6.  The command
 *   ./6
 * will then read lines from the standard input (one boolean
 * expression per line) and print out whether it is true. */

/* Operator precedence and associativity, listed from lowest to highest. 
 * These declarations will resolve conflicts such as ``if we've 
 * recognized e*e in the input and the next symbol is "+", should we
 * assume that (1) e*e came from the production e->e*e, or should we 
 * assume that (2) the second 'e' is going to be part of a later e+e?'' 
 * If * has higher precedence that + (is listed after + in the declarations 
 * below), then the answer is (1), and otherwise (2).  For a situation
 * of equal precendence, such as seeing e+e when the next symbol is +, 
 * we can choose to group the initial e+e together---indicated by %left---
 * or group as if the input were e+(e+e)---indicated by %right. */

%left '+' '-'
%left '*' '/'

%{
# define YYERROR_DECLARED 

  static int yyerror (const char*);
%}

%%

expr: expr ('+'|'-'|'*'|'/') expr %expand
 | '-'? '(' expr ')'
 | atom
 ;

atom: tuple | list | number | var_name | var_name '(' csv ')' | var_name '(' atom ')';

tuple: '(' csv ')'
 | '(' csv ",)"
 | '(' atom ",)";

list: '[' csv ']'
 | '[' csv ']'
 | '[' csv ",]"
 | '[' atom ",]";

csv: atom csv_end;
csv_end: ',' atom | ',' atom csv_end;


number: '-'? (posint | posfloat);
posint: digit+;
posfloat: scinot | decimal;
decimal: posint '.' posint
 | posint '.'
 | '.' posint;
scinot: (posint | decimal |) 'e' ('+'|'-'|) posint;

var_name_begin: '_' | letter;
var_name_body: (alphanum | '_') var_name_body | (alphanum | '_');
var_name: var_name_begin var_name_body | var_name_begin;

alphanum: letter | digit;
letter: lowercase | uppercase;
digit: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
lowercase : 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z';
uppercase : 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z';

/* LEXICAL RULES (you don't have to touch these) */

*: ' ' | '\t' | '\n' | '\r' ;

%%

#include <cctype>
#include <iostream>
#include <string>

using namespace std;

/* The following program reads boolean expressions written one per line
 * on the standard input, and then reprints them, indicating which are
 * accepted by the grammar above. */
main ()
{
    while (true) {
	string input;
	getline (cin, input);
	if (cin.eof ())
	    return 0;
	if (input.find_last_not_of (' ') == input.npos)
	    continue;
	yylex_init ();
	yypush_lexer (input, "?");
        int yyp = yyparse();
        printf("yyp: %d\n",yyp);
	if (yyp == 0)
	    cout << "\"" << input <<  "\" is accepted." << endl;
	else
	    cout << "\"" << input << "\" is not accepted." << endl;
    }
}

static int
yyerror (const char*) {
  
}

