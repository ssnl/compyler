/* -*- mode: fundamental; c-file-style: "stroustrup"; indent-tabs-mode: nil -*- */

/* apyc: Bison Parser */

/* Authors: YOUR NAMES HERE */

%define semantic_tree_type "AST"

%{
  #include <string>
  #include "apyc.h"
  #include "ast.h"

  using namespace std;

  static AST_Ptr theTree;

  /* Utilities */
  /** Return a new unop node corresponding to OPERANDS, which is the list of
   *  right-hand-side semantic values of a unop production (consisting of a
   *  token for the operator, followed by the AST for the operand). */
  static AST_Ptr make_unop (const List_Ptr& operands);

  /** Return a new binop node corresponding to OPERANDS, which is the list of
   *  right-hand-side semantic values of a binop production (consisting of an
   *  AST for the first operand, a token for the operator, and an AST for the
   *  second operand). */
  static AST_Ptr make_binop (const List_Ptr& operands);

  /** Return a new ID node, where the text of the identifier is given by
   *  TOKEN. */
  static AST_Ptr make_id (AST_Ptr& token);

  /** Return a new KEY node corresponding to OPERANDS. */
  static AST_Ptr make_expr (const int KEY, const List_Ptr& operands);

%}

%debug
%define error_function error

/* A token declaration such as
 *   %token INDENT
 * declares a new integer constant INDENT, which serves as a syntactic category
 * (suitable for output by the lexer) identifying a kind of token, which we
 * also often refer to as INDENT. A declaration such as
 *   %token IF "if"
 * defines a constant IF and makes it the syntactic category for the token
 * "if".  The built-in function yyexternal_token_name(...) maps between
 * syntactic categories (like IF) and the token strings defined in these
 * %token declarations (like "if").
 *
 * The Horn system uses tokens as leaf nodes and as AST node operators.  A
 * rule such as
 *     if_stmt: "if"^ expression ":"! ...
 * with no action, by default creates an AST node whose operator is an "if"
 * token (with syntactic category IF, given the %token declaration above).
 * When the node type does not correspond to a token that appears in the
 * program, we define a dummy token type that serves only as an AST
 * node type.  For example, we can define
 *     %token DICT_DISPLAY ...
 * and then use
 *     dict_display: "{"! key_datum_list? "}"!
 *              { $$ = $^(DICT_DISPLAY, $*); }
 * in the grammar (using DICT_DISPLAY only in actions, not as a grammar
 * symbol).
 *
 * In this skeleton, we've used a simple kludge to extract the printed forms
 * of AST operators from the operators themselves.  When a token such as IF
 * is the operator, yyexternal_token_name returns the operator name directly.
 * When there is no such correspondence, as with DICT_DISPLAY, we'll define
 *     %token DICT_DISPLAY "@dict_display"
 * Since "@dict_display" is not a valid token (it would be an error for this
 * to appear in any Python program) and does not appear in the grammar, this
 * declaration has no effect on the language recognized.  However, it
 * still provides an easy way to find the external name of an operator (just
 * strip off the leading "@").  (We can't just use "dict_display", since that
 * would tell Horn to define 'dict_display' as a token, whereas it would be a
 * simple identifier if it actually appeared in a Python program.  This is
 * where the kludginess comes in.) The AST_Tree::external_name method does
 * this conversion, converting tokens that are supposed to represent
 * node operators to printable strings.
 */

%token ID

%token PRINTLN "@println"
%token EMPTY
%token EXPR_LIST "@expr_list"
%token MODULE "@module"
%token BINOP "@binop"
%token UNOP "@unop"
/* Statements */
%token STMT_LIST "@stmt_list"
%token PRINT "@print"
%token RETURN "@return"
%token BREAK "@break"
%token CONTINUE "@continue"
/* Expressions */
%token COMPARE "@compare"
%token LCOMPARE "@left_compare"
%token AND "@and"
%token OR "@or"
%token IF_EXPR "@if_expr"
%token TUPLE "@tuple"
%token LIST "@list_display"
%token DICT "@dict_display"
%token PAIR "@pair"
%token EXPO "**"
/* Associativity + Precedence */
%left "or"
%left "and"
%left "in" "notin"
%left "is" "isnot"
%left '<' '>' "<=" ">=" "==" "!="
%left '+' '-'
%left '%' '*' '/'
%left "&&" "||"
%right EXPO

%%

program : stmt_list   { theTree = $^(MODULE, $*); $$ = NULL; }
        ;

/* REPLACE THE FOLLOWING WITH SOMETHING REAL. */

stmt_list :
      (statement '\n'!)+
                      { $$ = $^(STMT_LIST, $*); }
    | /*empty*/       { $$ = $^(STMT_LIST); }
    ;

statement :
        "print"! expression_list
                      { $$ = $^(PRINTLN, $^(EMPTY), $*); }
      | "print"! expression0 "<<"! ','! expression_list
                      { $$ = $^(PRINTLN, $*); }
      | "return"! expression0
                      { $$ = $^(RETURN, $*); }
      | "break"!
                      { $$ = $^(BREAK); }
      | "continue"!
                      { $$ = $^(CONTINUE); }
      ;

expression_list :
      expression (","! expression)*
                      { $$ = $^(EXPR_LIST, $*); }
    | /*empty*/       { $$ = $^(EXPR_LIST); }
    ;

// tuple_ext_expr:
//      expression
//    | expression ','! (expression ','!)* expression?
//                      { $$ = $^(TUPLE, $*); }
//    ;

expression0 :
      expression
    | /* empty */     { $$ = $^(EMPTY); }
    ;

expression :
      root_expr
    ;

root_expr :
      if_expr
    | boolean_expr
    ;

if_expr :
      E0=boolean_expr "if"! T=root_expr "else"! E1=root_expr
                    { $$ = $^(IF_EXPR, $T, $E0, $E1); }
    ;

boolean_expr :
      arith_expr
    | compare_expr
    | boolean_expr (type="and"!|type="or"!) boolean_expr %expand
                    { int token_id = $type.value()->as_string().compare("and") == 0 ? AND : OR;
                      $$ = $^(token_id, $*);
                    }
    ;

compare_expr :
      lcompare_expr ('<'|'>'|"<="|">="|"=="|"!="|"in"|"notin"|"is"|"isnot") arith_expr %expand
                    { $$ = make_expr(COMPARE, $*); }
    ;

lcompare_expr :
      arith_expr
    | lcompare_expr ('<'|'>'|"<="|">="|"=="|"!="|"in"|"notin"|"is"|"isnot") arith_expr %expand
                    { $$ = make_expr(LCOMPARE, $*); }
    ;

arith_expr :
      unary_expr
    | arith_expr ('+'|'-'|'*'|'/'|'%') arith_expr %expand
                      { $$ = make_binop($*); }
    ;

unary_expr :
      expo_expr
    | ('+'|'-'|"not") unary_expr %expand
                      { $$ = make_unop($*); }
    ;

expo_expr :
      primary_expr
    | expo_expr EXPO expo_expr
                      { $$ = make_binop($*); }
    ;

primary_expr :
      INT_LITERAL
    | str_expr
    | dict
    | '(' ')'
                      { $$ = $^(TUPLE); }
    | '[' ']'
                      { $$ = $^(LIST); }
    | '('! expression ','!  (expression ','!)* expression? ')'!
                      { $$ = $^(TUPLE, $*); }
    | '['! expression  (','! expression)* ','!? ']'!
                      { $$ = $^(LIST, $*); }
    | '('! root_expr ')'!
    ;

pair :
      P1=expression ':'! P2=expression
                      { $$ = $^(PAIR,$P1,$P2); }
    ;

dict :
      '{'! ((pair '\n'! ','!)|(pair ','! '\n'!?))* pair? '}'!
                      { $$ = $^(DICT, $*); }
    ;

str_expr :
      STRING
    | RAWSTRING
    | (S=RAWSTRING|S=STRING) str_expr %expand
                      { string s = ((AST_Token *) $str_expr.value().data())->string_text();
                        ((AST_Token *) $S.value().data())->append_text(s);
                        $$ = $S.value();
                      }
    ;



/* Normally, throw away whitespace other than newline. */
* : (' ' | '\t' | '\r')+ ;

UNUSED_KEYWORD : ("as" | "assert" | "del" | "except" | "exec" | "finally" | "future" |
                  "global" | "import" | "lambda" | "raise" | "try" | "with" | "yield" |
                  "from")
                      { error($TEXT, "Syntax Error: invalid syntax"); }
    ;

_DIGIT : '0' .. '9' ;

_LETTER : 'A' .. 'Z' | 'a' .. 'z' ;

ID : (_LETTER | '_') (_LETTER | _DIGIT | '_')* ;

INT_LITERAL : ('1' .. '9') ('0' .. '9')* | '0' ;

STRING :
      '\"' ((_ANY - ('\"' | '\n'))* "\\\"")* (_ANY - ('\"' | '\n'))* '\"'
                      { $$ = AST::make_token (STRING, $TEXT_SIZE - 2,
                                              $TEXT+1, false);
                      }
    | '\'' ((_ANY - ('\'' | '\n'))* "\\\'")* (_ANY - ('\'' | '\n'))* '\''
                      { $$ = AST::make_token (STRING, $TEXT_SIZE - 2,
                                              $TEXT+1, false);
                      }
    | "\"\"\"" ((_ANY - '\"')+ ('\"' '\"'?)?)* "\"\"\""
                      { $$ = AST::make_token (STRING, $TEXT_SIZE - 6,
                                              $TEXT+3, false);
                      }
    | "\'\'\'" ((_ANY - '\'')+ ('\'' '\''?)?)* "\'\'\'"
                      { $$ = AST::make_token (STRING, $TEXT_SIZE - 6,
                                              $TEXT+3, false);
                      }
    ;

RAWSTRING :
      "r\"" ((_ANY - ('\"' | '\n'))* "\\\"")* (_ANY - ('\"' | '\n'))* '\"'
                      { $$ = AST::make_token (RAWSTRING, $TEXT_SIZE - 3,
                                              $TEXT+2, false);
                      }
    | "r\'" ((_ANY - ('\'' | '\n'))* "\\\'")* (_ANY - ('\'' | '\n'))* '\''
                      { $$ = AST::make_token (RAWSTRING, $TEXT_SIZE - 3,
                                              $TEXT+2, false);
                      }
    | "r\"\"\"" ((_ANY - '\"')+ ('\"' '\"'?)?)* "\"\"\""
                      { $$ = AST::make_token (RAWSTRING, $TEXT_SIZE - 7,
                                              $TEXT+4, false);
                      }
    | "r\'\'\'" ((_ANY - '\'')+ ('\'' '\''?)?)* "\'\'\'"
                      { $$ = AST::make_token (RAWSTRING, $TEXT_SIZE - 7,
                                              $TEXT+4, false);
                      }
    ;

%%

bool debugParser;

static AST_Ptr
make_unop (const List_Ptr& operands)
{
    return YYMAKE_TREE (UNOP, make_id (operands->at (0)), operands->at (1));
}

static AST_Ptr
make_binop (const List_Ptr& operands)
{
    return YYMAKE_TREE (BINOP, operands->at (0), make_id (operands->at (1)),
                        operands->at (2));
}

static AST_Ptr
make_id (AST_Ptr& token)
{
    AST_Ptr result = AST::make_token (ID, token->text_size (),
                                      token->as_chars (), false);
    result->set_loc (token->loc ());
    return result;
}

static AST_Ptr
make_expr (const int KEY, const List_Ptr& operands)
{
    return YYMAKE_TREE (KEY, operands->at (0), make_id (operands->at (1)),
                        operands->at (2));
}

int
AST::lineNumber ()
{
    return yylocation_line (loc ());
}

void
parse (FILE* f, const string& name)
{
    if (debugParser)
        yydebug = 1;
    yypush_lexer (f, name);
    theTree = NULL;
    yyparse ();
    if (theTree != NULL) {
        theTree->print (cout, 0);
    }
}
